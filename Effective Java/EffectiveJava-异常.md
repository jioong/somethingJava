# 异常 #
  
充分发发挥异常的优点，可以提高程序的可读性、可靠性和可维护性。如果使用不当，也会带来负面影响。  
  
## 只针对异常的情况才使用异常 ##
  
* 异常机制的初衷是用于不正常的情形，所以很少会有 *JVM* 实现企图对它们进行优化，使得与显示的测试一样快速。  
* 把代码放在 *try-catch* 块中反而阻止了现代 *JVM* 实现本来可能要执行的某些特定优化。  
* 对数组进行遍历的标准模式并不会导致冗余的检查。  

  
**异常应该只用于异常的情况下：它们永远不应该用于正常的控制流。**更一般的说，应该优先使用标准的、容易理解的模式，而不是那些声称可以提供更好性能的、弄巧成拙的方法。  
设计良好的 *API* 不应该强迫它的客户端为了正常的控制流而是用异常。如果类具有“状态相关 (*state-dependent*)” 的方法，即只有在特定的不可预知的条件下才可以被调用的方法，这个类往往也应该有个单独的“状态测试 (*state-testing*) ”方法，即指示是否可以调用这个状态相关的方法。例如， *Iterator* 接口有一个“状态相关”的 *next()* 方法，和相应的状态测试方法 *hasNext()* 。  
  
对集合进行迭代的标准模式：  
```Java
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ){  
	Foo foo = i.next();
}  
```  
  
如果缺少 *hasNext()* 方法，客户端将被迫改用：   
```Java
try{
	Iterator<Foo> i = collection.iterator();
	while(true){
		Foo foo = i.next();
		...
	}
} catch(NoSuchElementException e){
	...
}
```  
  
另一种提供单独的状态测试方法的做法是，如果“状态相关的”方法被调用时，该对象处于适当的状态之中，就会返回一个可识别的值。  
  
**总结**：  
* 异常是为了在异常使用的情况下使用而设计的。  
* 不要将异常用于普通的控制流。  

## 对可恢复的情况使用受检异常，对编程错误使用运行时异常 ##
  
*Java* 提供了三种可抛出结构( *throwable* ): 受检异常 *checked exception* ，运行时异常 *run-time exception* ,错误 *error* 。  
  
在决定使用受检的异常或是未受检的异常时，主要的原则是：**如果期望调用者能够适当地回复，对于这种情况就应该使用受检的异常。**通过抛出受检的异常，强迫调用者在一个 *catch* 子句中处理该异常，或者将它传播出去。因此，方法声明中要抛出的每个受检的异常，都是对 *API* 用户的一种潜在指示，与异常相关联的条件是调用这个方法的一种可能的结果。  
  
有两种未受检的可抛出结构：运行时异常和错误。在行为上两者是等同的：它们都是不需要也不应该被捕获的可抛出结构。如果程序抛出未受检的异常或者错误，往往属于不可恢复的情形，继续执行下去有害无益。如果，没有捕获到这样的可抛出结构，将会导致当前的线程停止，并出现恰当的错误消息。  
**用运行时异常来表明编程错误。** 大多数的运行时异常都表示提前违例 *precondition violation* 。所谓提前违例是指 *API* 的客户没有遵守 *API* 规范建立的约定。  
  
要想定义一个抛出结构，它不是 *Exception, RuntimeException, Error* 的子类，也是可能的。  
总而言之，对于可恢复的情况，使用受检的异常；对于程序错误，则使用运行时异常。  
异常也是完全意义上的对象，可以在它上面定义任意的方法。这些方法的主要用途是为捕获异常的代码而提供额外的信息，特别是关于引发这个异常条件的信息。如果没有这样的方法，程序员必须要懂得如何解析“该异常的字符串表示法”，以便获得额外的信息。  
  
  
## 避免不必要地使用受检的异常 ##
  
受检异常与返回代码不同，它们强迫程序员处理异常的条件，大大的增强了可靠性。  
如果抛出一个或者多个受检异常，调用该方法的代码就必须在一个或多个 *catch* 块中处理这些异常，或者它必须声明它抛出这些异常，并让它们传播出去。无论哪种方法，都会带来不可忽视的负担。  
如果正确地使用 *API* 并不能阻止这种异常条件的产生，并且一旦产生异常，使用 *API* 的程序员可以立即采取有用的动作，这种负担就被认为是正当的。除非这两个条件都成立，否则更适合于使用未受检异常。
  
## 优先使用标准的异常 ##
  
重用现有的异常有多方面的好处。其中最重要的好处是，它使 *API* 更加易于学习和使用，因为它与程序员已经熟悉的习惯用法是一致的。第二个好处是，对于用到这些 *API* 的程序而言，它们的可读性会更好，因为它们不会初选很多程序员不熟悉的异常。最后，异常类越少，意味着内存印迹就越小，装载这些类的时间开销也越小。  
  
常见的异常：  
* *IllegalArgumentException* --- 非 *null* 的参数值不正确  
* *IllegalStateException* --- 对于方法调用而言，对象状态不合适  
* *NullPointerException* --- 在禁止使用 *null* 的情况下参数值为 *null*  
* *IndexOutOfBoundesException* --- 下标参数值越界  
* *ConcurrentModificationException* --- 在禁止并发修改的情况下，检测到对象的并发修改  
* *UnsupportedOperationException* --- 对象不支持用户请求的方法  

**一定要确保抛出异常的条件与该异常的文档中描述的条件一致。**  
  
## 抛出与抽象相对应的异常 ##
  
如果方法抛出的异常与它所执行的任务没有明显的联系，这种情形将会使人不知所措。  
**更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常，这种做法叫做异常转译 (exception translation) 。**  
```Java
// Excep[tion Translation
try{
	//Use lower-level abstration to do our bidding
	...
} catch (LowerLevelException e) {
	throw new HighLevelException(...);
}  
```  
  
一种特殊的异常转译形式称为异常链 (*exception chaining*)，如果底层的异常对于调试调试导致高层异常的问题非常有帮助，使用异常链就很合适。底层的异常(原因)被传到高层的异常，高层的异常提供访问方法 (*Throwable.getCause*) 来获得底层的异常。  
```Java
// Exception Chaining
try{
	...
} catch (LowerLevelException e) {
	throw new HigherLevelException(cause);
}
```  
高层异常的构造器将原因传到支持链 (*chaining-aware*) 的草鸡构造器，因此它最终将被传给 *Throwable* 的其中一个运行异常链的构造器。  
**在给底层传递参数之前，检查更高层方法的参数的有效性，从而避免底层方法抛出异常。**  
如果无法避免底层异常，次选方案是，让更高层来悄悄绕开这些异常，从而将高层方法的调用者与底层的问题隔离开来。  
  
**总结**：  
* 如果不能阻止或处理来自更低层的异常，一般的做法是使用异常转译。除非低层方法碰巧可以保证它抛出的所有异常对高层也合适才可以将异常从低层传播到高层。  
* 异常链对高层和低层异常都提供了最佳的功能：它允许抛出适当的高层异常，同时又能捕获底层的原因惊醒失败分析。  

## 每个方法抛出的异常都要有文档 ##
  
* 始终要单独地声明受检的异常，并且利用 *javadoc* 的 *@throws* 标记，准确地记录下抛出每个异常的条件。  
* 使用 *Javadoc* 的 *@throws* 标签记录下一个方法可能抛出的每个未受检异常，但是不要使用 *throws* 关键字将未受检的异常包含在方法的声明中。   
* 如果一个类中的许多方法出于同样的原因而抛出同一个异常，在该类的文档注释中对这个异常建立文档，而不是为每个方法单独建立文档。   
  
## 在细节消息中包含能捕获失败的信息 ##
  
当程序由于未被捕获的异常而失败时，系统会自动打印出该异常的堆栈轨迹。在堆栈轨迹中包含该异常的字符串表示法 (*String Representation*), 即它的 *tostring* 方法的调用结果。它通常包含该异常的类名、紧随气候的是细节消息 (*detail message*) 。通常，这只是程序员或者域服务人员 (*filed service personnel* , 指检查软件失败的人) 在调查软件失败原因时必须检查的信息。如果失败的情形不容易重现，要想获得更多的信息会非常的困难，甚至是不可能的。因此，异常类型的 *tostring()* 方法应该尽可能多的返回有关失败原因的信息。  
**异常的细节消息应该捕获住失败，便于以后分析。**  
  
为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。虽然在异常的细节消息中包含所有相关的“硬数据” (*hard data*) 是非常重要的，但是包含大量的描述信息往往没有意义。  
  
> 堆栈轨迹的用途是与源文件结合起来进行分析，它通常包含抛出该异常的确切文件和行数，以及堆栈中所有其他方法调用所在文件和行数。    

异常的细节消息不应该与”用户层次的消息错误“混为一谈，后者对于最终用户而言必须是可以理解的。与用户层次的错误消息不同，异常的字符串表示法主要是让程序员来分析失败的原因。因此，消息的内容比可理解性要重要得多。  
为了确保在异常的细节消息中包含足够的能捕获失败的信息，一种办法多大是在异常的构造器而不是字符串细节消息中引入这些消息。  
  
## 努力使失败保持原子性 ##
  



**来源于：Joshua Bloch 《Effective Java 中文版》**    