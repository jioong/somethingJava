# 泛型 #
  
*Java 1.5* 版本中增加了泛型 *Generic* 。  
**在没有泛型之前**，从集合中读取到的每个对象都必须进行转换。如果不小心插入了类型错误的对象，**在运行时**的转换处理会出错。  
**在有了泛型之后**，可以告诉编译器每个集中中接受哪些对象类型。编译器会自动的为插入进行转换，并在编译时告知是否插入了类型错误的对象。这样可以是程序既更加安全，也更加清楚。  
  
## 请不要在新代码中使用原生态类型 ##
  
1. 声明中具有一个或者多个类型参数( *type parameter* ) 的类或者几口，就是泛型 ( *generic* ) 类或者接口。泛型类和接口统称为泛型( *generic type* )。  
2. 每种泛型定义一组参数化的类型 (*parameterized type*), 构成格式为：先是类或者接口的名称，接着是尖括号 <> 把对应于泛型形式类型参数的实际类型参数列表括起来。如 *List<String>*, 是一个参数化的类型，表示元素类型为 *String* 的列表。  
3. 每个泛型都定义一个原生态类型 (*raw type*)，即不带任何实际类型参数的泛型名称。例如，与 *List<E>* 相对应的原生态类型是 *List*。 **原生态类型就像从类型声明中删除了所有泛型信息一样。**实际上，原生态类型 *List* 与 *Java* 平台没有泛型之前的接口类型 *List* 完全一样。  
  
如果不提供类型参数，使用集合类型和其他泛型也仍是合法的，但不应该这么做。如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。任然提供原生态类型的目的是为了提供兼容性。**移植兼容性促成了支持原生态类型。**  
  
使用参数化的类型以允许插入任意的对象也是可以的，如 *List< Object>*。那原生态类型 *List* 和参数化的类型 *List< Object>* 之间到底有什么区别呢？不严格的说，前者逃避了泛型检查，后者则明确的告知编译器，它能够持有任意类型的对象。可以将 *List<Stng>* 传递给类型 *List* 的参数，但是不能传递给类型为 *List< Object>* 的参数。  
> 泛型有子类型化 (*subtyping*) 的规则，*List<String>* 是原生态类型 *List* 的一个子类型，但不是参数化类型 *List< Object>* 的子类型。因此，如果使用向 *List* 这样的原生态类型，就会失掉了类型安全性，但是如果使用 *List< Object>* 这样的参数化类型，则不会。  
  
在不确定或者不在乎集合中元素的类型的情况下，也许可以使用原生态类型。从*Java 1.5* 发行版本开始，*Java* 提供了一种安全的替代原生态类型的方法，称作为 无限制的通配符类型 (*unbounded wildcard type*)。如果要使用泛型，但是不确定或者不关心实际的类型参数，就可以使用一个问号 *？* 代替。如，泛型 *Set<E>* 的无限制通配符类型为 *Set<?>* (读作“某个类型的集合”) 。这是最普通的参数化 *Set* 类型，**可以持有任何集合。**  
无限制通配类型 *Set<?>* 和原生态类型 *Set* 之间有什么区别？通配符类型是安全的，原生态类型则是不安全的。由于可以将任何元素放进使用原生态类型的集合中，因此很容易破坏该集合的类型约束条件。但是不能将任何元素(除了 *null* 之外) 放到通配符类型中。  
  
不要再新代码中使用原生态类型，这条规则有两个小小的例外，两者都源于“泛型信息可以在运行时被擦除”这一事实。  
* 在类文字 *class literal* 中必须使用原生态类型。 *List.class* 合法， *List<String>.class* 不合法。  
* 在参数化类型而非无限制通配符类型上使用 *instanceof* 操作符是非法的。用无限制通配符类型代替原生态类型，对 *instanceof* 操作符的行为不会产生任何影响。  
  
```Java
if (o instanceof Set){
	Set<?> m = (Set<?>) o;
	...
}
```  

注意，一旦确定 *o* 是 *Set*，就必须将它转换为通配符类型 *Set<?>*,而不是转换为原生态类型 *Set*。  
  
**总结**：  
* *Set< Object>* 是个参数化类型，表示可以包含任何对象类型的一个集合。  
* *Set<?>* 则是一个通配符类型，表示只能包含某种未知对象类型的一个集合；  
* *Set* 则是原生态类型，它脱离了泛型的系统。前两者是安全的，最后一种不安全。  
  
## 消除非受检警告 ##
  
用泛型编程时，会遇到许多编译器警告：非受检强制转化警告(*unchecked cast warnings*)、非受检方法调用警告、非受检普通数组创建警告，以及非受检转换警告(*unchecked conversion warnings*)。  
要尽可能是消除每一个非受检警告。如果消除了所有的警告，就可以确保代码是类型安全的。  
如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以用一个 *@ SuppressWarnings("unchecked")* 注解来禁止这条警告。  
*SuppressWarnings* 注解可以用在任何粒度的级别中，从单独的局部变量声明到整个类都可以。应该始终在尽可能小的范围中使用 *SuppressWarnings* 注解。永远不要再整个类上使用 *SuppressWarnings*。  
每当使用 *SuppressWarnings("unchecked")* 注解时，都要添加一条注释，说明为什么这么做是安全的。  
  
**总结**：  
* 非受检警告很重要，不要忽略它们。  
* 每一条警告都表示可能在运行时抛出 *ClassCastException* 异常。  
* 尽最大努力消除警告。如果无法消除非受检警告，同时可以证明引起警告的到吗是类型安全的，可以在尽可能小的范围中使用注解禁止该警告。  
* 要用注释把禁止该警告的原因记录下来。   
  
## 列表优先于数组 ##
  
数组与泛型相比，有两个重要的不同点：  
1. 数组是协变的 (*covariant*)。表示如果 *Sub* 为 *Super* 的子类型，那么数组类型 *Sub[]* 就是 *Super[]* 的子类型。相反的，泛型则是不可变的 (*invariant*): 对于任意两个不同类型 *Type1, Type2* , *List<Type1>* 既不是 *List<Type2>* 的子类型，也不是父类型。  
2. 数组是具体化的 (*reified*) ,因此数组会**在运行时** 才知道并检查它们的元素类型约束。相比之下，泛型则是通过擦除 (*erasure*) 来实现的。因此泛型 **只在编译时** 强化它们的类型信息，并在运行时丢弃(或者擦除)它们的元素类型信息。  
  
> 擦除就是是泛型可以与没有使用泛型的代码随意进行胡勇。  
  
由于上述这些根本的区别，因此数组和泛型不能很好第混合使用。例如，创建泛型、参数化类型或者类型参数的数组都是非法的。  
  
为什么创建泛型数组是非法的？因为它部署类型安全的。要是它合法，编译器在其他正确的程序中发生的转换就会在运行时失败，并出现一个 *ClassCastException* 异常。就违背了泛型系统提供的基本保证。  
  
从技术角度来说，像 *E、List<E>、List<String>* 这样的类型应称作不可具体化的 (*non-reifiable*) 类型，直观的说，不可具体化的类型是指其运行时表示法包含的信息比它的编译时表示法包含的信息更少的类型。唯一可具体化的参数化类型是无限制的通配符类型，如 *List<?>*。创建无限制通配符类型的数组是合法的。  
  
**总结**：  
1. 数组是协变且可以具体化的；泛型是不可变的且可以被擦除的
2. 数组提供了运行时的安全，但是没有编译时的类型安全。   
  
  
**来源于：Joshua Bloch 《Effective Java 中文版》**                                                    