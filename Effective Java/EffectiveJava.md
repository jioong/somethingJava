# Effective Java 笔记 #

## 创建和销毁对象 ##

### 考虑用静态工厂方法代替构造器 ###
  
静态工厂方法(*static factory method*), 只是一个返回类的实例的静态方法。注意，静态工厂方法与设计模式中的工厂方法模式不同。  
提供静态工厂方法而不是共有构造器具有以下优势：   
1. 静态工厂方法与构造器不同的第一大优势在于，它们有名称。当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且慎重的选择名称以突出它们之间的区别。
2. 第二大优势在于，不必在每次调用它们的时候创建一个新的对象。  
3. 第三大优势在于，它们可以返回原返回类型的任何子类型的对象。  
4. 第四大优势在于，在创建参数化实例的时候，它们使代码变得更加简洁。  
  
静态工厂方法的缺点：  
1. 第一个缺点在于，类如果不含共有的或者受保护的构造器，就不能被子类化。   
2. 第二大缺点在于，它们与其它的静态方法实际没有任何区别。  

### 遇到多个构造器参数时要考虑用构建器 ###
  
静态工厂方法和狗在其有共同的局限性：它们不能很好地扩展到大量的可选参数。  
**重叠构造器(telescoping constructor) 模式**，提供第一个只有必要参数的构造器，第二个构造器有一个可选参数，第三个有两个可选参数，以此类推，最后一个构造器包含所有可选参数。当有许多参数的时候，客户端的代码会很难编写，并且难以阅读。  
遇到许多构造器参数的时候，可以用**JavaBeans 模式**代替。在这种模式下，调用一个无参构造器来创建对象，然后调用 *setter* 方法来设置每个必要的参数，以及每个相关的可选参数。
  
```Java
// 构造器
public NutritionFacts(){
//setter method 设置对应属性的值，不需要设置的则为默认值
public void setSomething(int val) (something = val);
......
}

//创建对象
NutritionFacts cocaCola = new NutritionFacts();
cocaCola.setSomethiong(设置的参数值);
// 设置所有想要设置的参数
```  
  
该模式的缺点在于，因为构造过程被分到了几个调用中，在创建过程中 *JavaBean* 可能处于不一致的状态。类无法仅仅通过检验构造器参数的有效性来保持一致。试图使用处于不一致状态的对象，将会导致失败且调试非常困难。另一点不足在于， *JavaBean* 模式阻止了把类做成不可变的可能。   
  
### 用私有构造器或者枚举类型强化 Singleton 属性 ###
  
*Singleton* 指仅仅被实例化一次的类，通常用来表示那些本质上唯一的系统组件。   
  
## 对于所有对象都通用的方法 ##
  
### 覆盖 equals 时请遵守通用约定 ###
  
1. 类的每个实例本质上是唯一的。  
2. 不关心类是否提供了“逻辑检查”的测试功能。  
3. 超类已经覆盖了 *equals*, 从超类继承过来的行为对于子类也是合适的。  
4. 类是私有的或是包级私有的，可以确定它的 *equals* 方法永远不会被调用。  

**equals 方法实现的等价关系**  
* 自反性 *reflexxive*  
* 对称性 *symmetric*  
* 传递性 *transitive*  
* 一致性 *consistent*  
* 对于任何非 *null* 的引用值 *x*, *x.equals(null)* 必须返回 *false*  

## 类和接口 ##
  
  类和接口是 *Java* 程序设计语言的核心，也是 *Java* 语言的基本抽象单元。  
  
### 使类和成员的可访问性最小化 ###
   
要区别设计良好的模块与设计不好的模块，最重要的因素在于，这个模块对于外部的其他模块而言，是否隐藏其内部数据和其实现细节。**好的设计，把 API 与实现清晰的隔离开来。**   
信息隐藏 *information hiding* 、 封装 *encapsulation*  
实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符(*private、protected、public*) 共同决定的。  
  
第一规则很简单：**尽可能的使每个类或者成员不被外界访问。**对于顶层的(非嵌套的)类和接口，只有两种访问级别，包级私有(*package-private*)和共有的(*public*)。如果类或者接口能够被做成包级私有，它就应该被做成包级私有，这样把它变成包的实现的一部分，而不是该包导出的 *API* 的一部分。  
对于成员的访问级别：  
* 私有的 ---> 只有在声明该成员的顶层类内部才可以访问该成员。  
* 包级私有的 ---> 声明该成员的包内部的任何类都可以访问这个成员。其实就是**缺省(default)访问级别**，未指定访问修饰符时，使用该访问级别。  
* 受保护的 ---> 声明该成员的类的子类可以访问该成员，并且声明该成员的包内部的任何类也可以访问该成员。  
* 共有的 ---> 在任何地方都可以访问该成员。  

如果方法覆盖了超类中的一个方法，子类中的访问级别就不允许低于超类中大访问级别。  
实例域决不能是共有的，包含有共有可变域的类并不是线程安全的。  
  
### 在共有类中使用访问方法而非共有域 ###
  
如果类可以在它所在包的外部进行访问，就提供访问方法 *setter, getter*。  
如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误。