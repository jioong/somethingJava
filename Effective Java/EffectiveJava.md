# Effective Java 笔记 #

## 创建和销毁对象 ##

### 考虑用静态工厂方法代替构造器 ###
  
静态工厂方法(*static factory method*), 只是一个返回类的实例的静态方法。注意，静态工厂方法与设计模式中的工厂方法模式不同。  
提供静态工厂方法而不是共有构造器具有以下优势：   
1. 静态工厂方法与构造器不同的第一大优势在于，它们有名称。当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且慎重的选择名称以突出它们之间的区别。
2. 第二大优势在于，不必在每次调用它们的时候创建一个新的对象。  
3. 第三大优势在于，它们可以返回原返回类型的任何子类型的对象。  
4. 第四大优势在于，在创建参数化实例的时候，它们使代码变得更加简洁。  
  
静态工厂方法的缺点：  
1. 第一个缺点在于，类如果不含共有的或者受保护的构造器，就不能被子类化。   
2. 第二大缺点在于，它们与其它的静态方法实际没有任何区别。  

### 遇到多个构造器参数时要考虑用构建器 ###
  
静态工厂方法和狗在其有共同的局限性：它们不能很好地扩展到大量的可选参数。  
**重叠构造器(telescoping constructor) 模式**，提供第一个只有必要参数的构造器，第二个构造器有一个可选参数，第三个有两个可选参数，以此类推，最后一个构造器包含所有可选参数。当有许多参数的时候，客户端的代码会很难编写，并且难以阅读。  
遇到许多构造器参数的时候，可以用**JavaBeans 模式**代替。在这种模式下，调用一个无参构造器来创建对象，然后调用 *setter* 方法来设置每个必要的参数，以及每个相关的可选参数。
  
```Java
// 构造器
public NutritionFacts(){
//setter method 设置对应属性的值，不需要设置的则为默认值
public void setSomething(int val) (something = val);
......
}

//创建对象
NutritionFacts cocaCola = new NutritionFacts();
cocaCola.setSomethiong(设置的参数值);
// 设置所有想要设置的参数
```  
  
该模式的缺点在于，因为构造过程被分到了几个调用中，在创建过程中 *JavaBean* 可能处于不一致的状态。类无法仅仅通过检验构造器参数的有效性来保持一致。试图使用处于不一致状态的对象，将会导致失败且调试非常困难。另一点不足在于， *JavaBean* 模式阻止了把类做成不可变的可能。   
  
### 用私有构造器或者枚举类型强化 Singleton 属性 ###
  
*Singleton* 指仅仅被实例化一次的类，通常用来表示那些本质上唯一的系统组件。   
  
## 对于所有对象都通用的方法 ##
  
### 覆盖 equals 时请遵守通用约定 ###
  
1. 类的每个实例本质上是唯一的。  
2. 不关心类是否提供了“逻辑检查”的测试功能。  
3. 超类已经覆盖了 *equals*, 从超类继承过来的行为对于子类也是合适的。  
4. 类是私有的或是包级私有的，可以确定它的 *equals* 方法永远不会被调用。  

**equals 方法实现的等价关系**  
* 自反性 *reflexxive*  
* 对称性 *symmetric*  
* 传递性 *transitive*  
* 一致性 *consistent*  
* 对于任何非 *null* 的引用值 *x*, *x.equals(null)* 必须返回 *false*