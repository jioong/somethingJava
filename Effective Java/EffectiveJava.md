# Effective Java 笔记 #

## 创建和销毁对象 ##

### 考虑用静态工厂方法代替构造器 ###
  
静态工厂方法(*static factory method*), 只是一个返回类的实例的静态方法。注意，静态工厂方法与设计模式中的工厂方法模式不同。  
提供静态工厂方法而不是共有构造器具有以下优势：   
1. 静态工厂方法与构造器不同的第一大优势在于，它们有名称。当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且慎重的选择名称以突出它们之间的区别。
2. 第二大优势在于，不必在每次调用它们的时候创建一个新的对象。  
3. 第三大优势在于，它们可以返回原返回类型的任何子类型的对象。  
4. 第四大优势在于，在创建参数化实例的时候，它们使代码变得更加简洁。  
  
静态工厂方法的缺点：  
1. 第一个缺点在于，类如果不含共有的或者受保护的构造器，就不能被子类化。   
2. 第二大缺点在于，它们与其它的静态方法实际没有任何区别。  

### 遇到多个构造器参数时要考虑用构建器 ###
  
静态工厂方法和狗在其有共同的局限性：它们不能很好地扩展到大量的可选参数。  
**重叠构造器(telescoping constructor) 模式**，提供第一个只有必要参数的构造器，第二个构造器有一个可选参数，第三个有两个可选参数，以此类推，最后一个构造器包含所有可选参数。当有许多参数的时候，客户端的代码会很难编写，并且难以阅读。  
遇到许多构造器参数的时候，可以用**JavaBeans 模式**代替。在这种模式下，调用一个无参构造器来创建对象，然后调用 *setter* 方法来设置每个必要的参数，以及每个相关的可选参数。
  
```Java
// 构造器
public NutritionFacts(){
//setter method 设置对应属性的值，不需要设置的则为默认值
public void setSomething(int val) (something = val);
......
}

//创建对象
NutritionFacts cocaCola = new NutritionFacts();
cocaCola.setSomethiong(设置的参数值);
// 设置所有想要设置的参数
```  
  
该模式的缺点在于，因为构造过程被分到了几个调用中，在创建过程中 *JavaBean* 可能处于不一致的状态。类无法仅仅通过检验构造器参数的有效性来保持一致。试图使用处于不一致状态的对象，将会导致失败且调试非常困难。另一点不足在于， *JavaBean* 模式阻止了把类做成不可变的可能。   
  
### 用私有构造器或者枚举类型强化 Singleton 属性 ###
  
*Singleton* 指仅仅被实例化一次的类，通常用来表示那些本质上唯一的系统组件。   
  
## 对于所有对象都通用的方法 ##
  
### 覆盖 equals 时请遵守通用约定 ###
  
1. 类的每个实例本质上是唯一的。  
2. 不关心类是否提供了“逻辑检查”的测试功能。  
3. 超类已经覆盖了 *equals*, 从超类继承过来的行为对于子类也是合适的。  
4. 类是私有的或是包级私有的，可以确定它的 *equals* 方法永远不会被调用。  

**equals 方法实现的等价关系**  
* 自反性 *reflexxive*  
* 对称性 *symmetric*  
* 传递性 *transitive*  
* 一致性 *consistent*  
* 对于任何非 *null* 的引用值 *x*, *x.equals(null)* 必须返回 *false*  

## 类和接口 ##
  
  类和接口是 *Java* 程序设计语言的核心，也是 *Java* 语言的基本抽象单元。  
  
### 使类和成员的可访问性最小化 ###
   
要区别设计良好的模块与设计不好的模块，最重要的因素在于，这个模块对于外部的其他模块而言，是否隐藏其内部数据和其实现细节。**好的设计，把 API 与实现清晰的隔离开来。**   
信息隐藏 *information hiding* 、 封装 *encapsulation*  
实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符(*private、protected、public*) 共同决定的。  
  
第一规则很简单：**尽可能的使每个类或者成员不被外界访问。**对于顶层的(非嵌套的)类和接口，只有两种访问级别，包级私有(*package-private*)和共有的(*public*)。如果类或者接口能够被做成包级私有，它就应该被做成包级私有，这样把它变成包的实现的一部分，而不是该包导出的 *API* 的一部分。  
对于成员的访问级别：  
* 私有的 ---> 只有在声明该成员的顶层类内部才可以访问该成员。  
* 包级私有的 ---> 声明该成员的包内部的任何类都可以访问这个成员。其实就是**缺省(default)访问级别**，未指定访问修饰符时，使用该访问级别。  
* 受保护的 ---> 声明该成员的类的子类可以访问该成员，并且声明该成员的包内部的任何类也可以访问该成员。  
* 共有的 ---> 在任何地方都可以访问该成员。  

如果方法覆盖了超类中的一个方法，子类中的访问级别就不允许低于超类中大访问级别。  
实例域决不能是共有的，包含有共有可变域的类并不是线程安全的。  
  
### 在共有类中使用访问方法而非共有域 ###
  
如果类可以在它所在包的外部进行访问，就提供访问方法 *setter, getter*。  
如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误。  
  
### 使可变性最小 ###
  
不可变类只是其实例不能被修改的类，每个实例中包含的所有信息都必须在创建该实例的时候提供，并在对象的整个声明周期内固定不变。为了使类成为不可变类，须遵循一下五条规则：  
1. 不要提供任何会修改对象状态的方法。  
2. 保证类不会被扩展。为了防止子类化，一般做法是使这个类成为 *final* 。  
3. 使所有的域都为 *final* 的。  
4. 使所有的域都成为私有的。这样可以防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象。  
5. 确保对于任何可变组件的互斥访问。如果类具有指向可变对象的域。则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象引用。  

**不可变对象本质上是线程安全的，他们不要求同步。不可变对象可以自由的被共享。不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。**  
  
### 接口优于抽象类 ###
  
用来定义允许多个实现的类型：接口和抽象类。这两种机制之间最明显的区别在于，抽象类允许包含某些方法的实现，但是接口则不允许有实现。更为重要的区别在于，为了实现由抽象类定义的类型，类必须成为抽象类的子类。  
**现有的类可以很容易被更新，以实现新的接口。**  
**接口是定义混合类型(mixin)的理想选择。** *mixin*是指这样的类型：类处理实现它的“基本类型”之外，还可以实现这个 *mixin* 类型，以表明它提供了某些可供选择的行为。  
**接口允许构造非层次结构的类型框架。**  
  
设计公有的接口要非常谨慎：接口一旦被公开发行，并且已经被广泛使用，再想改这个接口几乎是不可能的。**必须在初次设计的时候就保证接口是正确的。**  
  
### 接口只用于定义类型 ###
  
当类实现接口时，接口就充当可以引用这个类的实例的类型。有一种接口被成为常见接口(*constant interface*)，这种接口没有任何方法，只包含静态的 *final* 域，每个域都导出一个常量。  
常量接口模式是对接口的不良使用。  
**接口应该只被用例定义类型，不应该被用来导出常量。**  
  
### 用函数对象表示策略 ###
  
*Java* 没有提供函数指针，但是可以用对象引用实现同样的功能。调用对象上的方法通常是执行该对象(*that object*) 上的某项操作。也可以定义一种对象，它的方法执行其他对象(*other object*) (这些对象被显式传递给这些方法) 上的操作。如果一个类仅仅只导出这样的一个方法，它是实例实际上就等同于一个指向该方法的指针，这样的实例被称为**函数对象 (function object)**。  
  
在设计具体的我策略类时，还需要定义一个策略接口(*strategy interface*)。  
  
### 优先考虑静态成员类 ###
  
嵌套类(*nested class*) 是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为它的外围类(*enclosing class*) 提供服务。如果嵌套类将来可能会用于其他的某个环境中，它就应该是顶层类(*top-level class*)。嵌套类有四中：  
* 静态成员类 *static member class*  
* 非静态成员类 *nonstatic member class*  
* 匿名类 *anonymous class*  
* 局部类 *local class*  

除了第一种外，其他三种都称为内部类 *inner class*。  
  
**静态成员类**可以访问外围类的所有成员，包括那些声明为私有的成员。静态成员类是外围类的一个静态成员，与其他的静态成员一样，也遵循同样的可访问性规则。如果它被声明为私有，就只能在外围类的内部才可以被访问。静态成员类的一种常见用法是作为共有的辅助类，仅当与它的外围类一起使用时才有意义。  
从语法上讲，静态成员类与非静态成员类的唯一的区别是，静态成员类的声明中包含修饰符 *static* 。