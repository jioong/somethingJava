# 正则表达式 #

**Ken Thompson**
> 正则表达式是描述一组字符串特征的模式，用来匹配特定的字符串。


## 边界 ##

> 断言标记边界，但并不耗用字符。也就是说，字符并不会返回到结果中。  

断言也被称作**零宽度断言(zero-width assertion)**。零宽度断言不匹配字符，而是**匹配字符串中的位置。**

### 行的起始于结束 ###

1. 根据上下文， ^ 会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。**上下文依赖于应用程序和在应用程序中所使用的选项。**
2. 美元符 $ 匹配行末或字符串的结尾位置。

### 单词边界与非单词边界 ###

1. \b  匹配单词边界。
2. \B  匹配非单词边界。
3. 在有些应用程序中，用 **\<**指定单词的开头，用**\>**指定单词结尾。(这是比较旧的语法，在很多最新的正则表达式应用程序中无法使用。)

## 选择、分组和后向引用 ##

### 选择操作 ###

**选择操作可在多个可选模式中匹配一个。**  

竖线  |   

**正则表达式中的选项**
<center>  
<table>
	<tr>
		<td>选项</td>
		<td>描述</td>
		<td>支持平台</td>
	</tr>
	<tr>
		<td>(?d)</td>
		<td>Unix中的行</td>
		<td>Java</td>
	</tr>
	<tr>
		<td>(?i)</td>
		<td>不区分大小写</td>
		<td>PCRE,Perl,Java</td>
	</tr>
	<tr>
		<td>(?J)</td>
		<td>允许重复的名字</td>
		<td>PCRE</td>
	</tr>
	<tr>
		<td>(?m)</td>
		<td>多行</td>
		<td>PCRE,Perl,Java</td>
	</tr>
	<tr>
		<td>(?s)</td>
		<td>单行(dotall)</td>
		<td>PCRE,Perl,Java</td>
	</tr>
	<tr>
		<td>(?u)</td>
		<td>Unicode</td>
		<td>Java</td>
	</tr>
	<tr>
		<td>(?U)</td>
		<td>默认最短匹配</td>
		<td>PCRE</td>
	</tr>
	<tr>
		<td>(?x)</td>
		<td>忽略空格和注释</td>
		<td>PCRE,Perl,Java</td>
	</tr>
	<tr>
		<td>(?-...)</td>
		<td>复原或关闭选项</td>
		<td>PCRE</td>
	</tr>
</table>
</center>

### 子模式(subpattern) ###

多数情况下，提到正则表达式中的子模式，**就是指分组中的一个或多个分组。**  
子模式：就是模式中的模式。多数情况下，子模式中的条件能得到匹配的前提是前面的模式得到匹配。  

### 捕获分组和后向引用 ###

当一个模式的全部或者部分内容由一对括号分组时，它就**对内容进行捕获并临时存储于内存中。**金额通过后向引用重用捕获的内容。  

    \1   or    $1
	这里引用的是第一个捕获的分组。而 \2 引用第二个捕获的分组。

### 命名分组(named group) ###

命名分组就是有名字的分组。这样，就可以通过名字(而不是数字)来引用分组。  

    命名分组：
			(?<name>...)
	引用分组：
			\k<name> 或 \k'name'

### 非捕获分组(Non-Capturing Group) ###

非捕获分组不会将其内容存储在内存中。由于不存储内容，非捕获分组会带来较高的性能。

    非捕获分组：
			(?: ....)

### 原子分组(atomic group) ###

原子分组也是一种非捕获分组。如果使用的正则表达式引擎进行回溯操作，这种分组就可以将回溯操作关闭，但它**只针对原子分组内的部分，而不是针对整个正则表达式。**  

    语法：
		(?> ...)

正则表达式处理过程缓慢的一个因素就是回溯操作。其原因就是回溯操作会尝试每一种可能性，这会消耗时间和计算资源。

## 字符组 ##

### POSIX 字符组 ###

POSIX(Portable Operating System Interface, 可移植操作系统接口)。  

正则表达式标准(ISO/IEC/IEEE 9945:2009)，提供了一套命名字符组

    形式：
		[[:xxxxx:]]  
		[[:^xxxx:]]   是对上面对应的字符组取反。

1.  [[:alnum:]]  匹配字母及数字。
2.  [[:alpha:]]  匹配大小写字母。
3.  [[:ascii:]]  匹配ACSII范围内的字符。
4.  [[:space:]]  匹配空格会制表符。
5.  [[:blank:]]  匹配所有空白字符。
6.  [[:digit:]]  匹配数字。
7.  [[:graph:]]  匹配图形字符。
8.  [[:lower:]]  匹配小写字母。
9.  [[:upper:]]  匹配大写字母。
10. [[:word:]]   匹配单词字符。
11. [[:ctrl:]]   匹配控制字符。
12. [[:print:]]  匹配可打印字符。
13. [[:punct:]]  匹配标点符号。
14. [[:xdigit:]] 匹配十六进制数字。  

## 匹配Unicode和其他字符 ##

[Unicode标准](http://www.unicode.org "Unicode标准") 

    \u 之后紧跟十六进制值。

	八进制数
		\ddd   ---   反斜线后加三位数字。

## 量词 ##

### 贪心、懒惰和占有 ###

量词自身是贪心的。  
1. 贪心的量词会首先匹配整个字符串。尝试匹配时，它会选定尽可能多的内容，也就是整个输入。如果失败则回退一个字符后再次尝试。这个过程叫做**回溯(backtracking)。**它每次回退一个字符，直到找到匹配的内容或者没有字符可尝试为止。  
此外，它还记录所有的行为，因此它对资源的消耗最大。   
2. 懒惰(勉强)使用另一种策略。它从目标的起始位置开始尝试寻找匹配，每次检查字符串的一个字符，寻找它要匹配的内容。最后，它会尝试匹配整个字符串。要是一个量词称为懒惰的，必须在普通量词后添加一个**问号(?)**。  
3. 占有量词会覆盖整个目标然后尝试寻找整个匹配内容，但它只尝试一次，**不会回溯。**占有量词就是在普通量词之后添加一个**加号(+)**。

### 用 *、+和？进行匹配 ###

<center>
	<table>
		<tr>
			<td>语法</td>
			<td>描述</td>
		</tr>
		<tr>
			<td>?</td>
			<td>零个或一个</td>
		</tr>
		<tr>
			<td>+</td>
			<td>一个或多个</td>
		</tr>
		<tr>
			<td>*</td>
			<td>零个或多个</td>
		</tr>
	</table>
</center>

### 匹配待定次数 ###

使用花括号可以限制某个模式在**某个范围内匹配的次数**,未经修饰的量词就是贪心量词。  

花括号是最灵活和精确的量词。  

**范围语法总结**  
1. {n}      精确匹配 n 次。
2. {n,}     匹配 n 次或更多次。
3. {m,n}    匹配 m 至 n 次。
4. {0,1}    与 ？ 相同。
5. {1,}     与 +  相同。
6. {0,}     与 *  相同。

### 懒惰量词 ###

懒惰的基本特性就是**匹配尽可能少**的字符。

### 占有(possessive)量词 ###

占有式匹配很想贪心式匹配，它会选定**尽可能多的内容。**与贪心式匹配不同的是，**不进行回溯。**它不会放弃所找到的内容。  
有点是速度快，因为不需要回溯。  

## 环视 ##

环视是一种非捕获分组，它根据某个模式之前或之后的内容匹配其他模式。环视也称为**零宽度断言。**
环视模式只是用来定位文本中的位置。

### 正前瞻 ###

    (?=...)

### 反前瞻 ###

意味着要匹配某个模式时，需要在它后面**找不到**含有给定前瞻模式的内容。

    (?!...)

### 正后顾 ###

查看左边的内容。  

    (?<=...)

### 反后顾 ###

    (?<!...)