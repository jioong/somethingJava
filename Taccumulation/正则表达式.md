# 正则表达式 #
  
## 基础 ##
  
正则表达式 *Regular Expression* 是一种匹配模式，找出字符串的特征。  
  
### 占有字符和零宽度 ###
  
正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，则认为该**子表达式是占有字符的**。如果子表达式匹配的仅仅是位置，或者内容并不保存到最终的匹配结果中，那么就认为该**子表达式是零宽度的**。  
占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的。  
占有字符是互斥的，零宽度是非互斥的。也就是说一个字符，同一时间只能由一个子表达式匹配。而，一个位置却可以同时由多个零宽度的子表达式匹配。  
  
可以理解：字符对于子表达式是私有的，而位置则是共有的。  
  
### 正则表达式构成 ###
  
正则表达式由两种字符构成。一种是，在正则表达式中具有特殊意义的 **元字符** 。另一种是普通的 **文本字符** 。  
元字符可以是一个字符，也可以是一个字符序列。  
  
## 元字符 (Meta Character) ##
  
### [...] 字符组 ###
  
字符组 *Character Classes* 可以匹配 **[]** 中包含的任意一个字符。 **可以是任意一个，但也只能是一个。**  
* 字符组支持由连字符 **"-"** 来表示一个范围。当 **"-"** 前后构成范围时，要求前面字符的码位小鱼后面字符的码位。  
* **[^...]** 排除型字符组， 表示任意一个未列出的字符，同样只能是一个。其中，也支持连字符来表示一个范围。  

  
### 常见字符范围缩写 ###
  
* \d ---> 任意一个数字，相当于 [0-9] 。  
* \w ---> 任意一个字母或下划线，相当于 [a-zA-Z0-9_] 。  
* \s ---> 任意空白字符， 相当于 [\r\n\f\t\v] 。  
* \D ---> 任意一个非数字字符， 相当于 [^0-9] 。  
* \W ---> \w 取反 。  
* \S ---> 任意非空白字符。  
* .  ---> 匹配除换行符 *\n* 以外的任意一个字符 。  

### 其他元字符 ###
  
* ^ ---> 匹配字符串开始的位置，不匹配任何字符。  
* $ ---> 匹配字符串结束的位置，不匹配任何字符。  
* \b ---> 匹配单词边界，不匹配任何字符。  

### 转义字符 ###
  
一些不可见字符，或是在正则中具有特殊意义的元字符，如果像匹配字符本身，需要用 "\" 对其进行转义。  
  
* \r, \n   ---> 回车和换行。  
* \\       ---> 匹配 "\" 本身。  
* \^,\$,\. ---> 分别匹配 "^", "$", "." 。  

匹配本身需要进行转义的：  
** $ ^ { [ ( | ) * +？　＼　**　　
　　
### 量词 (Quantifier) ###
  
量词表示一个自表达式可以匹配的次数。量词可以用来修饰一个字符、字符组、或是用 （） 括起来的子表达式。一些常用的量词被定义为独立的元字符。  
* {m} ---> 表达式匹配 *m* 次。  
* {m,n} ---> 表达式匹配最少 *m* 次，最多 *n* 次。  
* {m,}  ---> 表达式最少匹配 *m* 次。  
* ？    ---> 表达式匹配 0 次或 1 次，相当于 {0,1}。  
* *     ---> 表达式匹配 0 次或任意多次，相当于 {0,}。  
* +     ---> 表达式匹配 1 次或多次，至少 1 次，相当于 {1，}。   

不要出现 "{1}" 这样的量词，会降低匹配效率和可读性，画蛇添足。   
  
### 分支结构 (Alternation) ###
  
当一个字符串的某一个子串具有多种可能时，采用分支结构来匹配， "|" 表示多个子表达式之间 **或** 的关系， "|" 是以 （） 限定范围的，如果在 "|" 左右两侧没有 （） 来限定范围，**那么它的作用范围为 | 左右两侧的整体。**  
  
## 进阶概念 ##
  
### 捕获组 (Capture Group) ###
  
捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或手动命名的组里，以供后面引用。  
  
* (Expression) ---> 普通捕获组，将子表达式 *Expression* 匹配的内容保存到以数字编号的组里。  
* (?<name>Expression) ---> 命名捕获组，将子表达式 *Expression* 匹配的内容保存到以 *name* 命名的组里。  

普通捕获组是以数字进行编号的，编号的规则是以 "(" 从左到右出现的顺序，从 1 开始进行编号。在通常情况下，编号为 0 的组表示整个表达式匹配的内容。  
命名捕获组可以通过捕获组名，而不是序列号对捕获内容进行引用，提供更便捷的引用方式，不用关注捕获组的序号，也不用担心表达式部分更新会导致引用错误的捕获组。  
  
### 非捕获组 ###
  
一些表达式中，不得不使用 (), 但又不需要保存 （） 中子表达式匹配的内容，这时可以使用非捕获组来抵消使用 () 进行捕获的作用。  
  
* (?:Expression) ---> 进行子表达式 *Expression* 的匹配，并将匹配内容保存到最终的整个表达式的匹配结果中，但 *Expressiond* 匹配的内容不单独保存到一个组内。  

### 反向引用 ###
  
捕获组内匹配的内容，可以在正则表达式的外部程序中进行引用，也可以在表达式中进行引用，表达式中引用发方式就是反向引用。  
反向引用通常用来查找重复的子串，或是限定某一子串成对出现。  
  
* \1, \2 ---> 对序号为 1 或 2 的捕获组的反向引用。  
* \k<name> ---> 对命名为 *name* 的捕获组的反向引用。  

**进行反向引用时，对应 () 中匹配的内容已经是固定的。**  
  
### 环视 (Look Around) ###
  
环视只进行子表达式的匹配，匹配内容不计入最终的匹配结果，**是零宽度的。**  
环视按照方向可分为顺序和逆序两种，按照是否匹配有肯定和否定两种，组合起来是四中环视。**环视相当于对所在位置加了一个附加条件。**  
  
* (?<=Expression)  ---> 逆序肯定环视，表示所在位置左侧能够匹配 *Expression* 。  
* (?<!Expression)  ---> 逆序否定环视，表示所在位置左侧不能匹配 *Expression* 。  
* (?=Expression)   ---> 顺序肯定环视，表示所在位置右侧能够匹配 *Expression* 。  
* (?!Expression)   ---> 顺序否定环视，表示所在位置右侧不能匹配 *Expression* 。   
  
**环视匹配的最终结果就是一个位置。**环视的作用就相当于对所在位置加上一个附加条件，只有满足这个条件，环视子表达式才能匹配成功。  
  
#### 环视匹配原理 ####
  
环视的难点在于找到正确的“位置”。  
1. 顺序环视匹配过程。  
对于 *（？=Expression）* 来说，当子表达式 *Expression* 匹配成功时， * (?=Expression) * 匹配成功，并报告匹配当前位置成功。对于否定环视来说，当子表达式匹配成功时，则环视匹配失败。当子表达式 *Expression* 匹配失败时， *(?!Expression)* 匹配成功，并报告匹配当前位置成功。

### 忽略优先和匹配优先 ###
  
也可以叫做正则表达式匹配的贪婪与非贪婪模式。  
标准量词修饰的子表达式，在可匹配可不匹配的情况下，总会尝试进行匹配，这种方式叫做匹配优先，或者贪婪模式。  
  
一些 *NFA* 正则引擎支持忽略优先量词，也就是在标准量词后加一个 "?" 。此时，在可匹配可不匹配的情况下，总会优先忽略匹配。只有子忽略之后该子表达式不能匹配成功时，才进行匹配，这种方式称为忽略优先，或非贪婪模式。忽略优先量词包括： "{m}?" , "{m, n}?" , "??" , "*?" , "+?" 等。

  
**来源于： [CSDN 雁过无痕 博客](http://blog.csdn.net/lxcnn/article/details/4268033 "雁过无痕")**