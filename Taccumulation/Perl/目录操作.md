2014/12/14 星期日 14:28:29 

# 目录操作 #

## 在目录树中移动 ##

程序运行时会以自己的工作目录(working directory)作为相对路径的起点。

**chdir操作符**可以改变当前的工作目录。  

**系统调用发生错误时，标量 $! 的值会含有一些信息。**  

## Glob ##

## 目录句柄(directory handle) ##

若想从**目录取得文件名列表**，还可以使用目录句柄。目录句柄看起来像文件句柄，使用起来也没有多大区别。  

1. 打开 opendir   替代 open
2. 读取 readdir   替代 readline
3. 关闭 closedir  替代 close  

所读取到的是目录里的文件名(或其他东西的名称)，而**不是文件内容**。   
和文件句柄一样，目录句柄会在程序结束时自动关闭，也会在重新打开另一个目录时自动关闭。  

所返回的文件列表并未按照任何特定的顺序排序。列表里包含了所有的而文件，尤其是以点开头的文件，特别是**点号**和**双点号**。  

**readdir操作符返回的文件名不包含路径名称，只是目录里的名称而已。**

## 递归的目录列表 ##

File::Find 函数库

## 操作文件与目录 ##

### 移除文件 ###

unlink操作符会删除文件。其参数是一个列表。  
unlink的返回值代表成功删除了多少个文件。  
当unlink执行失败时，信息中的 $! 变量会设置成操作系统错误的相关信息，这只有在每次处理一个文件名时才适用。因为每次对操作系统的请求失败时都会重设 $! 变量的内容。  

unlink 不能移除**目录**。

**某个文件可能你无法读取、写入、执行，甚至无法拥有；也就是说，它根本就是别人的文件，但是还是可以删除它。这是因为删除文件的权限跟文件本身的权限位无关，它取决于文件所在目录的权限位。**  

## 重命名文件 ##

    rename "old", "new";  

	可以将文件移到别的目录		
	
    rename "over_there/some/place/some_file", "some_file";  

只要运行程序的用户拥有足够的权限，就会将别的目录里名为some_file的文件移到当前目录。  

## 链接与文件 ##

所谓“经挂载的存储设备(mounted volume)”，指的是某个硬盘，其中可能含有任意数量的文件或目录。  

每个文件都会存储在一个**编好号的inode**里，可以把它想象成磁盘上的门牌号码。  

目录里除了其他内容外，一定会有两个特殊项目。第一个是 .(点号),代表的是目录本身。另一个则是 ..(双点号),指的是目录结构里高一层的目录。

要在目录里创建一个新文件时，系统会新增一个项目来记录文件名与新的 inode 编号。  

**系统怎么知道哪个 inode 可用？** 答案是：每个 Inode都会存储自己的链接数(link count)。如果 Inode 并未在任何目录里出现，它的链接数一定是零。因此，所有链接数为零的 inode 都可以用来存放新的文件。每当 inode 被加进目录里，链接数就会递增。当它在目录的列表里被移除时，链接数就会递减。  

**任何目录的链接数至少是2：一个位于它上层目录的列表里，一个位于它本身的列表里。除此之外，如果里面还有子目录，则每个子目录还会通过 .. 项目在增加一个链接。**  

**在目录列表中，任何 inode 所指向的数据都只能放在同一个经挂载的存储设备里。**  

不能为目录建立额外的名称。不能增加目录的链接数，也不能让两个经挂载的存储设备彼此链接。  

符号链接(symbolic link),也称为软链接(soft link),以便和之前的硬链接有所区分。

## 建立及移除目录 ##

mkdir函数  

    mkdir "dir_name", 0755 or warn "Cannot make dir_name directory: $!";

返回值为“真”代表成功，失败时则会设定 $!的值。  

**oct函数强制把字符串当成八进制数值处理**  

    my ($name, $perm) = @ARGV;
	mkdir $name, oct($perm) or die "cannot creat $name: $!"  

**移除空目录使用 rmdir 函数**

如果目录不是空的，则 rmdir操作符会执行失败。可以先用unlink来删除目录的内容，再试着移除**应该已近清空**的目录。

## 修改权限 ##

    chmod 0755, "filename1", "filename2", "...";

chmod会返回成功更改的项目数量。

## 更改隶属关系 ##

只要操作系统许可，就可以使用 chown 函数来更改一串文件的拥有者以及他们所属的组。 chown 会同时更改拥有者和所属组，它们必须以数值形式的用户标识符及组标识符来指定。  

    例子：
		my $user = 1004;
		my $group = 100;
		chown $user, $group, glob "*.0";

如果处理的是字符串，即用户名，和组名，只要利用**getpwnam**函数将名称转换为值，用**getgrnam**函数将组名转成数值  

    例子：
		defined(my $user = getpwnam "ljnux") or die "bad user";
		defined(my $group = getgrnam "root") or die "bad group";
		chown $user, $group, glob "/home/ljnux";

defined函数来确认返回值不是 undef。 如果所指定的用户名或组不存在，就会返回 undef。

**chown函数会返回受影响的文件数量，在错误发生时会设定 $! 值。**

## 更改时间戳 ##

utime 函数，它的前两个参数是新的访问时间和更改时间，和面接的是要更改时间戳的文件名列表。时间的格式采用的是内部时间戳的格式。  

“right now”是个方便的时间戳值，time 函数会以正确的格式返回这个值。  
如果想改当前目录下的所有文件，让它们看起来是在一天前被更改的，却是在此刻被访问  

    my $now = time;
	my $ago = $now - 24 * 69 * 60;
	utime $now, $ago, glob "*";