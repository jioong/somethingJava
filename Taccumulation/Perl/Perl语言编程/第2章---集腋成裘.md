2014/12/17 星期三 22:04:59 
# 集腋成裘 #

## 原子 ##

在Perl中处理的最小元素通常是单个字符。

## 分子 ##

Perl是一种形式自由(free-form)的语言，不过这并不表示Perl完全没有形式。  
形式自由的语言是指，你可以在你喜欢的任何地方放置空格、制表符和换行符。  

如果某一行以**=**开头，这个语句是合法的。从这一行向下，知道一个以**=cut**开头的行，着之间的所有内容都会被Perl忽略。  
被忽略的这些文本成为 pod 或“无格式旧式文档”(plain old documentation) 

## 内置数据类型 ##

Perl的三种基本数据类型为：标量、标量数组和标量散列(也称为关联数组)。  

标量是最基本的类型，可以由标量构成更复杂的结构。标量存储单个简单值，通常是一个字符串或一个数字。可以结合这种简单类型的元素形成另外两种**聚合类型**。

**2014/12/18 星期四 9:50:37 **

## 名字 ##

Perl提供两类命名空间(namespace)，通常称为符号表(symbol tables)和词法作用域(lexical scopes)。可以有任意多个符号表或词法作用域，不过定义的每一个名字**只能存储在某一个符号表或词法作用域中(而不能同时存储于多个命名空间中)。**  

符号表是全局散列，其中包含全局变量(包括其他符号表的散列)的符号表记录。  
词法作用域是未命名(unnamed)的便签簿(scratchpad)，它不在任何符号表中，而与程序中的一个代码块关联。此法作用域只包含这个代码块能看到的变量。  

在任何给定的命名空间中(不论是全局变量还是词法作用域),每个变量类型都有自己的**子命名空间**，由**印记(sigil)确定。**


## 名字查找 ##

Perl解析器在理解上下文中的一个未限定名时会使用以下规则：

1. 首先，Perl会查看当前代码块，确定这个代码块是否已经声明该变量(使用 my,our或state声明)。如果有一个 my 或 state 声明，则说明这个变量是词法作用域变量，**它不在任何包中，只存在于这个词法作用域中(即这个代码块的便签簿中)**。由于**词法作用域是未命名的，任何人都无法在该程序块之外访问这个变量。**
2. 如果没有这样的声明，Perl会查找包围这个代码块的上一层代码块(外围代码块)，在这个更大的代码块中查找是否有这个词法作用域变量。同样的，如果Perl找到这样一个变量声明，说明该变量只属于**从该变量声明到它所在代码块末尾的这个词法作用域(包括所有嵌套的代码块)。**如果Perl没找到这样一个声明，会重复步骤2，直到再无外围代码块。
3. 如果Perl发现再无外围代码块，则它会在**整个编译单元**中检查声明，就好像这个编译单元是一个代码块一样。**编译单元(compilation unit)**就是整个当前文件，或者是一个 **eval STRING操作符**当前编译的字符串。**如果编译单元是一个文件，这就是可能的最大词法作用域，**Perl不会在继续寻找词法作用域变量，所以将进入**步骤4**。不过，如果编译单元是一个字符串：运行时编译为Perl代码的字符串会假装这是一个代码块，处于运行 eval STRING 的采伐作用域中。所以，如果Perl没能在该字符串的词法作用域中找到这个变量，就假装 eval STRING 是一个块，然后在**回到步骤2**，只不过这一次是从 eval STRING 操作符的词法作用域开始，而不是从字符串内部的词法作用域开始。(？)
4. 如果到了这一步，说明Perl没有找到该变量的任何声明(my 或 state)。现在Perl会放弃寻找词法作用域变量，而**假设这个变量是一个包变量**。如果启用了**strict pragma**,现在就回得到一个错误，除非这个变量是**Perl的一个预定义变量**，或者**已经导入到当前包中。**
5. 如果外围词法作用域中没有找到包声明，Perl会在未命名的顶级包中查找变量名，如果没有指定名字标记，就会有一个名字 main。

## 标量变量 ##

**标量总包含单个值。这个值可以是一个数字、一个字符串或另外一个数据的引用。甚至可以根本没有值。**  

标量是**无类型**的，不必声明标量是整数、浮点数、字符串或是任何其他类型。

## 字符串直接量 ##

双引号字符串直接量**支持反斜线和变量内插。**单引号字符串不允许(除\'和\\以外，所以可以在单引号字符串中嵌入单引号和反斜线)  
如果想嵌入任何其他反斜线序列，必须使用双引号形式。

## 版本直接量 ##

如果一个直接量**以 v 开头而且后面跟有一个或多个用逗号分隔的十进制整数**，这会作为一个版本号

    use v5.14; # 打开strict 和警告

## 其他直接量 ##

**开头和结尾有一个双下划线的标识符都应看作是为Perl保留的，有特殊的语法用途。**  
1. __FILE__     表示程序当前文件名。  
2. __LINE__     表示程序当前行号。  
3. __PACKAGE__  表示当前的包名(当前行将要编译到这个包中)。  
4. __END__      用来指示脚本的逻辑结束(在真正文件末尾之前)。后面所有的文本都将被忽略，但是可以通过 DATA 文件句柄读取。  
5. __DATA__     在当前包的命名空间打开 DATA 文件句柄。

# 上下文(context) #

## 标量和列表上下文 ##

Perl脚本中调用的每一个操作会在**一个特定的上下文计算和执行**，这个操作的行为取决于这个上下文的需求。  
有两种主要的上下文：标量上下文和列表上下文。  

有些操作符知道自己所在的上下文，在需要列表的上下文会返回一个列表，在需要标量的上下文返回一个标量值。**返回类型的重载(overloaded)**  

## 布尔上下文(boolean context) ##

布尔上下文是一个**无关上下文**，它不会导致任何标量转换，不过当然会为那些关心类型的操作数提供标量上下文。

布尔上下文是指，要在这里计算表达式来查看它为true还是 false。  

**若果一个标量值不为空串""或数字0(或其字符串表示"0"),这个标量值就为true。**  
引用总为 true,因为它表示一个地址，而地址不会为 0。  
未定义的值(undef)总是false。因为未定义的值往往是""或是0(取决于把它作为一个字符串还是数字)。  
列表值没有布尔值，因为标量上下文中不会生成列表值。

## Void上下文 ##

该上下文并不关心返回值的类型是什么，它甚至不希望得到返回值。**从函数工作的角度来看，这与普通的标量上下文没有不同。**

## 内插上下文 ##


## 数组长度 ##



# 输入操作符 #

## 命令输入(反引号)操作符 ##

命令输入操作符，也称为反引号操作符，用法如下  

    $info = `perldoc $module`;  

用反引号引起的字符串**首先会像双引号字符串一样完成变量内插，再由系统将其结果解释为一个命令行，这个命令的输出就是这个伪直接量(pseudoliterals)的值。**  
在标量上下文中，会返回由所有输出构成的一个字符串。在列表上下文中，将返回一个值列表，每个值对应一个输出。

## 行输入(尖角)操作符 ##

readline 函数